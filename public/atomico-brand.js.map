{"version":3,"file":"atomico-brand.js","sources":["../node_modules/atomico/chunk/constants.js","../node_modules/atomico/chunk/utils.js","../node_modules/atomico/core.js","../src/components/atomico-brand/atomico-brand.js"],"sourcesContent":["const HOOK_MOUNT = Symbol(\"mount\");\r\nconst HOOK_MOUNTED = Symbol(\"mounted\");\r\nconst HOOK_UPDATE = Symbol(\"update\");\r\nconst HOOK_UPDATED = Symbol(\"updated\");\r\nconst HOOK_UNMOUNT = Symbol(\"unmount\");\r\nconst HOOK_CURRENT = {};\r\n\r\nconst ELEMENT_PROPS = Symbol(\"props\");\r\nconst ELEMENT_IGNORE_ATTR = Symbol(\"ignore\");\r\nconst ELEMENT_TRUE_VALUES = [true, 1, \"\", \"1\", \"true\"];\r\n\r\nconst ARRAY_EMPTY = [];\r\n\r\nconst NODE_TYPE = \"localName\";\r\n\r\nconst KEY = Symbol(\"key\");\r\n\r\nconst META_STYLE_SHEET = Symbol(\"styleSheet\");\r\n\r\nconst META_MAP_CHILDREN = Symbol(\"mapChildren\");\r\n\r\nconst META_KEYES = Symbol(\"keyes\");\r\n\r\nconst NODE_HOST = \"host\";\r\n\r\nconst IGNORE_CHILDREN = {\r\n    innerHTML: 1,\r\n    textContent: 1,\r\n    contenteditable: 1\r\n};\r\n\r\nconst JOIN_CHILDREN = {\r\n    style: 1\r\n};\r\n\r\nconst HYDRATE_PROPS = {\r\n    className: 1,\r\n    id: 1,\r\n    checked: 1,\r\n    value: 1,\r\n    selected: 1\r\n};\r\n\r\nconst CACHE_STYLE_SHEET = {};\r\n\r\nconst SUPPORT_STYLE_SHEET = \"adoptedStyleSheets\" in document;\r\n\r\nconst STYLE_SHEET_KEY = Symbol();\n\nexport { ARRAY_EMPTY as A, CACHE_STYLE_SHEET as C, ELEMENT_TRUE_VALUES as E, HOOK_CURRENT as H, IGNORE_CHILDREN as I, JOIN_CHILDREN as J, KEY as K, META_MAP_CHILDREN as M, NODE_HOST as N, SUPPORT_STYLE_SHEET as S, HOOK_MOUNT as a, HOOK_UPDATED as b, HOOK_MOUNTED as c, HOOK_UNMOUNT as d, HOOK_UPDATE as e, HYDRATE_PROPS as f, META_KEYES as g, META_STYLE_SHEET as h, STYLE_SHEET_KEY as i, NODE_TYPE as j, ELEMENT_IGNORE_ATTR as k, ELEMENT_PROPS as l };\n//# sourceMappingURL=constants.js.map\n","/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nfunction isArray(value) {\r\n    return Array.isArray(value);\r\n}\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nfunction isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction isFunction(value) {\r\n    return typeof value == \"function\";\r\n}\r\n\r\n// export function fps(callback, count = 3) {\r\n//     count-- ? requestAnimationFrame(() => fps(callback, count)) : callback();\r\n// }\r\n\r\nfunction promise(callback) {\r\n    return new Promise(callback);\r\n}\r\n\r\nfunction isRawNode(node) {\r\n    return node instanceof HTMLElement || node instanceof SVGElement;\r\n}\n\nexport { isEqualArray as a, isArray as b, isRawNode as c, isFunction as i, promise as p };\n//# sourceMappingURL=utils.js.map\n","import { H as HOOK_CURRENT, a as HOOK_MOUNT, b as HOOK_UPDATED, c as HOOK_MOUNTED, d as HOOK_UNMOUNT, e as HOOK_UPDATE, I as IGNORE_CHILDREN, f as HYDRATE_PROPS, K as KEY, S as SUPPORT_STYLE_SHEET, C as CACHE_STYLE_SHEET, M as META_MAP_CHILDREN, A as ARRAY_EMPTY, g as META_KEYES, h as META_STYLE_SHEET, i as STYLE_SHEET_KEY, N as NODE_HOST, J as JOIN_CHILDREN, j as NODE_TYPE, E as ELEMENT_TRUE_VALUES, k as ELEMENT_IGNORE_ATTR, l as ELEMENT_PROPS } from './chunk/constants.js';\nimport { i as isFunction, a as isEqualArray, b as isArray, c as isRawNode, p as promise } from './chunk/utils.js';\n\nfunction update(hook, type) {\r\n    hook[0] && (hook[1] = hook[0](hook[1], type));\r\n}\r\n\r\nfunction updateAll(hooks, type) {\r\n    for (let i in hooks) update(hooks[i], type);\r\n}\r\n\r\nfunction useHook(reducer, initialState) {\r\n    if (HOOK_CURRENT.ref.hook) {\r\n        return HOOK_CURRENT.ref.hook.use(reducer, initialState)[1];\r\n    }\r\n}\r\n\r\nfunction useRender() {\r\n    return HOOK_CURRENT.ref.render;\r\n}\r\n\r\nfunction useHost() {\r\n    return useHook(0, { current: HOOK_CURRENT.ref.host });\r\n}\r\n\r\nfunction createHookCollection(render, host) {\r\n    let hooks = {};\r\n    let mounted;\r\n    let hook = {\r\n        use,\r\n        load,\r\n        updated,\r\n        unmount\r\n    };\r\n\r\n    let ref = { hook, host, render };\r\n\r\n    function load(callback, param) {\r\n        HOOK_CURRENT.index = 0;\r\n        HOOK_CURRENT.ref = ref;\r\n        let resolve = callback(param);\r\n        HOOK_CURRENT.ref = 0;\r\n        return resolve;\r\n    }\r\n    function use(reducer, state) {\r\n        let index = HOOK_CURRENT.index++;\r\n        let mount;\r\n        // record the hook and the initial state of this\r\n        if (!hooks[index]) {\r\n            hooks[index] = [null, state];\r\n            mount = 1;\r\n        }\r\n        // The hook always receives the last reduce.\r\n        hooks[index][0] = reducer;\r\n        update(hooks[index], mount ? HOOK_MOUNT : HOOK_UPDATE);\r\n        return hooks[index];\r\n    }\r\n    function updated() {\r\n        let type = mounted ? HOOK_UPDATED : HOOK_MOUNTED;\r\n        mounted = 1;\r\n        updateAll(hooks, type);\r\n    }\r\n    function unmount() {\r\n        updateAll(hooks, HOOK_UNMOUNT);\r\n    }\r\n    return hook;\r\n}\r\n\r\nfunction useState(initialState) {\r\n    let render = useRender();\r\n    return useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = isFunction(initialState) ? initialState() : initialState;\r\n            state[1] = nextState => {\r\n                nextState = isFunction(nextState)\r\n                    ? nextState(state[0])\r\n                    : nextState;\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useEffect(callback, args) {\r\n    // define whether the effect in the render cycle should be regenerated\r\n    let executeEffect;\r\n    useHook((state, type) => {\r\n        if (executeEffect == null) {\r\n            executeEffect =\r\n                args && state[0] ? !isEqualArray(args, state[0]) : true;\r\n            state[0] = args;\r\n        }\r\n\r\n        switch (type) {\r\n            case HOOK_UPDATE:\r\n            case HOOK_UNMOUNT:\r\n                // save the current args, for comparison\r\n                if ((executeEffect || type == HOOK_UNMOUNT) && state[1]) {\r\n                    // compare the previous snapshot with the generated state\r\n                    state[1]();\r\n                    // clean the effect collector\r\n                    state[1] = 0;\r\n                }\r\n                // delete the previous argument for a hook\r\n                // run if the hook is inserted in a new node\r\n                // Why? ... to perform again dom operations associated with the parent\r\n                if (type == HOOK_UNMOUNT) {\r\n                    state[0] = null;\r\n                }\r\n                break;\r\n            case HOOK_MOUNTED:\r\n            case HOOK_UPDATED:\r\n                // save the current args, for comparison, repeats due to additional type HOOK_MOUNTED\r\n                if (executeEffect || type == HOOK_MOUNTED) {\r\n                    // save the effect collector\r\n                    state[1] = callback();\r\n                }\r\n                // save the comparison argument\r\n                break;\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useRef(current) {\r\n    return useHook(0, { current });\r\n}\r\n\r\nfunction useMemo(callback, args) {\r\n    let state = useHook(0, []);\r\n\r\n    if (!state[0] || (state[0] && (!args || !isEqualArray(state[0], args)))) {\r\n        state[1] = callback();\r\n    }\r\n    state[0] = args;\r\n    return state[1];\r\n}\r\n\r\nfunction useReducer(reducer, initialState) {\r\n    let render = useRender();\r\n    let hook = useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = initialState;\r\n            state[1] = action => {\r\n                let nextState = state[2](state[0], action);\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n    // allows the reduce to always access the scope of the component\r\n    hook[2] = reducer;\r\n\r\n    return hook;\r\n}\r\n/**\r\n * @todo add test use callback\r\n */\r\nfunction useCallback(callback, args) {\r\n    return useMemo(() => callback, args);\r\n}\n\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {Object} props\r\n * @param {Object} nextProps\r\n * @param {boolean} isSvg\r\n * @param {Object} handlers\r\n **/\r\nfunction diffProps(node, props, nextProps, isSvg, handlers) {\r\n    props = props || {};\r\n\r\n    for (let key in props) {\r\n        if (!(key in nextProps)) {\r\n            setProperty(node, key, props[key], null, isSvg, handlers);\r\n        }\r\n    }\r\n    let ignoreChildren;\r\n    for (let key in nextProps) {\r\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\r\n        ignoreChildren = ignoreChildren || IGNORE_CHILDREN[key];\r\n    }\r\n    return ignoreChildren;\r\n}\r\n\r\nfunction setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\r\n    key = key == \"class\" && !isSvg ? \"className\" : key;\r\n    // define empty value\r\n    prevValue = prevValue == null ? null : prevValue;\r\n    nextValue = nextValue == null ? null : nextValue;\r\n\r\n    if (key in node && HYDRATE_PROPS[key]) {\r\n        prevValue = node[key];\r\n    }\r\n\r\n    if (nextValue === prevValue) return;\r\n\r\n    if (\r\n        key[0] == \"o\" &&\r\n        key[1] == \"n\" &&\r\n        (isFunction(nextValue) || isFunction(prevValue))\r\n    ) {\r\n        setEvent(node, key, nextValue, handlers);\r\n        return;\r\n    }\r\n\r\n    switch (key) {\r\n        /**\r\n         * add support {@link https://developer.mozilla.org/es/docs/Web/API/CSSStyleSheet}\r\n         */\r\n        case \"styleSheet\":\r\n            if (SUPPORT_STYLE_SHEET)\r\n                node.shadowRoot.adoptedStyleSheets = []\r\n                    .concat(nextValue)\r\n                    .map(cssText => {\r\n                        if (cssText instanceof CSSStyleSheet) {\r\n                            return cssText;\r\n                        }\r\n                        if (!CACHE_STYLE_SHEET[cssText]) {\r\n                            CACHE_STYLE_SHEET[cssText] = new CSSStyleSheet();\r\n                            CACHE_STYLE_SHEET[cssText].replace(cssText);\r\n                        }\r\n\r\n                        return CACHE_STYLE_SHEET[cssText];\r\n                    });\r\n\r\n            break;\r\n        case \"ref\":\r\n            if (nextValue) nextValue.current = node;\r\n            break;\r\n        case \"style\":\r\n            setStyle(node, prevValue || \"\", nextValue || \"\");\r\n            break;\r\n        case \"key\":\r\n            node[KEY] = nextValue;\r\n            break;\r\n        default:\r\n            if (!isSvg && key != \"list\" && key in node) {\r\n                node[key] = nextValue == null ? \"\" : nextValue;\r\n            } else if (nextValue == null) {\r\n                node.removeAttribute(key);\r\n            } else {\r\n                node.setAttribute(\r\n                    key,\r\n                    typeof nextValue == \"object\"\r\n                        ? JSON.stringify(nextValue)\r\n                        : nextValue\r\n                );\r\n            }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {string} type\r\n * @param {function} [nextHandler]\r\n * @param {object} handlers\r\n */\r\nfunction setEvent(node, type, nextHandler, handlers) {\r\n    // get the name of the event to use\r\n    type = type.slice(type[2] == \"-\" ? 3 : 2);\r\n    // add handleEvent to handlers\r\n    if (!handlers.handleEvent) {\r\n        /**\r\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\r\n         **/\r\n        handlers.handleEvent = event => handlers[event.type].call(node, event);\r\n    }\r\n    if (nextHandler) {\r\n        // create the subscriber if it does not exist\r\n        if (!handlers[type]) {\r\n            node.addEventListener(type, handlers);\r\n        }\r\n        // update the associated event\r\n        handlers[type] = nextHandler;\r\n    } else {\r\n        // \tdelete the associated event\r\n        if (handlers[type]) {\r\n            node.removeEventListener(type, handlers);\r\n            delete handlers[type];\r\n        }\r\n    }\r\n}\r\n/**\r\n * define style as string inline,this generates less mutation\r\n * to the sun and cleans the previously defined properties.\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {(string|object)} prevValue\r\n * @param {(string|object)} nextValue\r\n */\r\nfunction setStyle(node, prevValue, nextValue) {\r\n    let style = node.style,\r\n        prevIsObject;\r\n    if (typeof prevValue == \"object\") {\r\n        prevIsObject = true;\r\n        for (let key in prevValue) {\r\n            if (!(key in nextValue)) setPropertyStyle(style, key, null);\r\n        }\r\n    }\r\n    if (typeof nextValue == \"object\") {\r\n        for (let key in nextValue) {\r\n            let value = nextValue[key];\r\n            if (prevIsObject && prevValue[key] === value) continue;\r\n            setPropertyStyle(style, key, value);\r\n        }\r\n    } else {\r\n        style.cssText = nextValue;\r\n    }\r\n}\r\n\r\nfunction setPropertyStyle(style, key, value) {\r\n    let method = \"setProperty\";\r\n    if (value == null) {\r\n        method = \"removeProperty\";\r\n        value = null;\r\n    }\r\n    if (~key.indexOf(\"-\")) {\r\n        style[method](key, value);\r\n    } else {\r\n        style[key] = value;\r\n    }\r\n}\n\nlet vNodeEmpty = createElement(null, { children: \"\" });\r\n\r\nlet vNodeFill = createElement(null, { children: ARRAY_EMPTY });\r\n\r\n/**\r\n * @param {VnodeType} nodeType\r\n * @param {VnodeProps} [props]\r\n * @param {Vnode|Vnode[]} [children]\r\n * @returns {Vnode}\r\n **/\r\nfunction createElement(nodeType, props, ...children) {\r\n    return { children, ...props, nodeType: nodeType || null };\r\n}\r\n/**\r\n * toVnode, processes the object for correct use within the diff process.\r\n **/\r\nfunction toVnode(value) {\r\n    if (isVnodeValue(value)) {\r\n        return value;\r\n    } else {\r\n        // this process occurs only once per vnode\r\n        if (!value[META_MAP_CHILDREN]) {\r\n            let { children, keyes } = mapChildren(value.children);\r\n            value.children = children.length ? children : ARRAY_EMPTY;\r\n            if (keyes) {\r\n                value[META_KEYES] = keyes;\r\n            }\r\n            value[META_MAP_CHILDREN] = true;\r\n        }\r\n        if (value.styleSheet && !SUPPORT_STYLE_SHEET) {\r\n            if (!value[META_STYLE_SHEET]) {\r\n                // When patching styleSheet, define whether to keep ARRAY_EMPTY\r\n                // or create a new array to fill and thus keep the reference intact\r\n                value.children =\r\n                    value.children == ARRAY_EMPTY ? [] : value.children;\r\n                // add the node to the children list\r\n                value.children.unshift(\r\n                    toVnode(\r\n                        createElement(\r\n                            \"style\",\r\n                            value[META_KEYES] ? { key: STYLE_SHEET_KEY } : {},\r\n                            value.styleSheet\r\n                        )\r\n                    )\r\n                );\r\n                // if it is a list with keys, add the key to keyes\r\n                if (value[META_KEYES]) {\r\n                    value[META_KEYES].unshift(STYLE_SHEET_KEY);\r\n                }\r\n            }\r\n            value[META_STYLE_SHEET] = true;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction mapChildren(children, scan = { children: [] }, deep = 0) {\r\n    if (isArray(children)) {\r\n        let length = children.length;\r\n        for (let i = 0; i < length; i++) {\r\n            mapChildren(children[i], scan, deep + 1);\r\n        }\r\n    } else {\r\n        if (children == null && !deep) return scan;\r\n\r\n        let vnode = toVnode(children);\r\n\r\n        if (vnode != null && typeof vnode == \"object\") {\r\n            if (isFunction(vnode.nodeType)) {\r\n                let { nodeType, ...props } = vnode;\r\n                return mapChildren(nodeType(props), scan, deep + 1);\r\n            }\r\n            if (\"key\" in vnode) {\r\n                scan.keyes = scan.keyes || [];\r\n                if (!~scan.keyes.indexOf(vnode.key)) {\r\n                    scan.keyes.push(vnode.key);\r\n                }\r\n            }\r\n        }\r\n\r\n        scan.children.push(vnode);\r\n    }\r\n    return scan;\r\n}\r\n\r\nfunction isVnodeEmpty(value) {\r\n    let type = typeof value;\r\n    return value == null || type == \"boolean\" || type == \"function\";\r\n}\r\n\r\nfunction fillVnodeValue(value) {\r\n    return isVnodeEmpty(value)\r\n        ? vNodeEmpty\r\n        : createElement(null, { children: \"\" + value });\r\n}\r\n\r\nfunction isVnodeValue(value) {\r\n    let type = typeof value;\r\n    return (\r\n        value == null ||\r\n        type == \"string\" ||\r\n        type == \"number\" ||\r\n        type == \"function\" ||\r\n        type == \"boolean\"\r\n    );\r\n}\r\n\r\n/**\r\n * @typedef {(Object<string,any>)} VnodeProps;\r\n *\r\n * @typedef {(Function|string)} VnodeType;\r\n *\r\n * @typedef {{type:VnodeType,props:VnodeProps}} Vnode\r\n **/\n\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {import(\"./vnode\").Vnode} nextVnode\r\n * @param {boolean} isSvg\r\n * @param {Function} currentUpdateComponent\r\n * @return {import(\"./render\").HTMLNode}\r\n **/\r\nfunction diff(id, node, nextVnode, isSvg) {\r\n    let { vnode, handlers = {} } = (node && node[id]) || {};\r\n\r\n    if (vnode == nextVnode && vnode != null) return node;\r\n\r\n    nextVnode = isVnodeValue(nextVnode) ? fillVnodeValue(nextVnode) : nextVnode;\r\n\r\n    let { nodeType, shadowDom, children, is, ...props } = vnode || vNodeFill;\r\n\r\n    let {\r\n        nodeType: nextNodeType,\r\n        shadowDom: nextShadowDom,\r\n        children: nextChildren,\r\n        is: nextIs,\r\n        ...nextProps\r\n    } = nextVnode;\r\n\r\n    isSvg = isSvg || nextNodeType == \"svg\";\r\n\r\n    if (\r\n        nextNodeType != NODE_HOST &&\r\n        (!equalNode(node, nextNodeType) || is != nextIs)\r\n    ) {\r\n        let nextNode = createNode(nextNodeType, isSvg, nextIs);\r\n        let parent = node && node.parentNode;\r\n        if (parent) {\r\n            parent.replaceChild(nextNode, node);\r\n        }\r\n\r\n        node = nextNode;\r\n        handlers = {};\r\n    }\r\n\r\n    if (JOIN_CHILDREN[nextNodeType]) {\r\n        nextNodeType = null;\r\n        nextChildren = nextChildren.join(\"\");\r\n    }\r\n    if (nextNodeType == null) {\r\n        if (node.textContent != nextChildren) {\r\n            node.textContent = nextChildren;\r\n        }\r\n    } else {\r\n        if (shadowDom != nextShadowDom) {\r\n            let { shadowRoot } = node;\r\n            let mode =\r\n                nextShadowDom && !shadowRoot\r\n                    ? \"open\"\r\n                    : !nextShadowDom && shadowRoot\r\n                    ? \"closed\"\r\n                    : 0;\r\n            if (mode) node.attachShadow({ mode });\r\n        }\r\n\r\n        let ignoreChildren = diffProps(\r\n            node,\r\n            props,\r\n            nextProps,\r\n            isSvg,\r\n            handlers);\r\n\r\n        if (!ignoreChildren && children != nextChildren) {\r\n            diffChildren(\r\n                id,\r\n                nextShadowDom ? node.shadowRoot : node,\r\n                nextChildren,\r\n                nextProps[META_KEYES],\r\n                isSvg\r\n            );\r\n        }\r\n    }\r\n    node[id] = { vnode: nextVnode, handlers };\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} parent\r\n * @param {import(\"./vnode\").Vnode[]} [nextChildren]\r\n * @param {boolean} isSvg\r\n */\r\nfunction diffChildren(id, parent, children, keyes, isSvg) {\r\n    let childrenLenght = children.length;\r\n    let { childNodes } = parent;\r\n    let childNodesKeyes = {};\r\n    let childNodesLength = childNodes.length;\r\n    let index = keyes\r\n        ? 0\r\n        : childNodesLength > childrenLenght\r\n        ? childrenLenght\r\n        : childNodesLength;\r\n\r\n    for (; index < childNodesLength; index++) {\r\n        let childNode = childNodes[index];\r\n        let key = index;\r\n        if (keyes) {\r\n            key = childNode[KEY];\r\n            if (keyes.indexOf(key) > -1) {\r\n                childNodesKeyes[key] = childNode;\r\n                continue;\r\n            }\r\n        }\r\n        index--;\r\n        childNodesLength--;\r\n        parent.removeChild(childNode);\r\n    }\r\n    for (let i = 0; i < childrenLenght; i++) {\r\n        let child = children[i];\r\n        let indexChildNode = childNodes[i];\r\n        let key = keyes ? child.key : i;\r\n        let childNode = keyes ? childNodesKeyes[key] : indexChildNode;\r\n\r\n        if (keyes && childNode) {\r\n            if (childNode != indexChildNode) {\r\n                parent.insertBefore(childNode, indexChildNode);\r\n            }\r\n        }\r\n\r\n        let nextChildNode = diff(id, childNode, child, isSvg);\r\n\r\n        if (!childNode) {\r\n            if (childNodes[i]) {\r\n                parent.insertBefore(nextChildNode, childNodes[i]);\r\n            } else {\r\n                parent.appendChild(nextChildNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {string} type\r\n * @param {boolean} isSvg\r\n * @returns {import(\"./render\").HTMLNode}\r\n */\r\nfunction createNode(type, isSvg, is) {\r\n    let doc = document;\r\n    let nextNode;\r\n    if (type != null) {\r\n        if (isRawNode(type)) {\r\n            return type;\r\n        }\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", type)\r\n            : doc.createElement(type, is ? { is } : null);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    return nextNode;\r\n}\r\n/**\r\n * compare 2 nodes, to define if these are equal\r\n * @param {string|null|HTMLElement|SVGElement} nodeA\r\n * @param {string|null|HTMLElement|SVGElement} nodeB\r\n */\r\nfunction equalNode(nodeA, nodeB) {\r\n    let isRawA = nodeA && isRawNode(nodeA);\r\n    let isRawB = nodeB && isRawNode(nodeB);\r\n    if (isRawB && isRawA) {\r\n        return isRawB == isRawB;\r\n    }\r\n    if (nodeA) {\r\n        if (!nodeA[NODE_TYPE]) {\r\n            nodeA[NODE_TYPE] = nodeA.nodeName.toLowerCase();\r\n        }\r\n\r\n        let localName = nodeA[NODE_TYPE];\r\n        return (localName == \"#text\" ? null : localName) == nodeB;\r\n    }\r\n}\n\nfunction render(vnode, node, id = \"vnode\") {\r\n    if (\r\n        vnode != null &&\r\n        typeof vnode == \"object\" &&\r\n        vnode.nodeType != NODE_HOST\r\n    ) {\r\n        vnode = createElement(NODE_HOST, { children: vnode });\r\n    }\r\n    vnode = toVnode(vnode);\r\n    diff(id, node, vnode);\r\n    return node;\r\n}\n\nfunction setAttr(node, attr, value) {\r\n    if (value == null) {\r\n        node.removeAttribute(attr);\r\n    } else {\r\n        node.setAttribute(\r\n            attr,\r\n            typeof value == \"object\" ? JSON.stringify(value) : value\r\n        );\r\n    }\r\n}\r\n\r\nfunction formatType(value, type = String) {\r\n    try {\r\n        if (type == Boolean) {\r\n            value = ELEMENT_TRUE_VALUES.indexOf(value) > -1;\r\n        } else if (typeof value == \"string\") {\r\n            value =\r\n                type == Number\r\n                    ? Number(value)\r\n                    : type == Object || type == Array\r\n                    ? JSON.parse(value)\r\n                    : type == Date\r\n                    ? new Date(value)\r\n                    : value;\r\n        }\r\n        if ({}.toString.call(value) == `[object ${type.name}]`) {\r\n            return { value, error: type == Number && Number.isNaN(value) };\r\n        }\r\n    } catch (e) {}\r\n\r\n    return { value, error: true };\r\n}\r\n\r\nfunction propToAttr(prop) {\r\n    return prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\r\n}\r\n\r\nfunction attrToProp(attr) {\r\n    return attr.replace(/-(\\w)/g, (all, letter) => letter.toUpperCase());\r\n}\r\n\r\nfunction dispatchEvent(node, type, customEventInit) {\r\n    node.dispatchEvent(\r\n        new CustomEvent(\r\n            type,\r\n            typeof customEventInit == \"object\" ? customEventInit : null\r\n        )\r\n    );\r\n}\n\nlet defer = Promise.resolve();\r\nlet queue = [];\r\nlet running;\r\n\r\nlet maxFps = 1000 / 60;\r\n\r\nconst IMPORTANT = Symbol(\"important\");\r\n\r\nfunction clearQueue() {\r\n    let time = performance.now();\r\n\r\n    let length = queue.length;\r\n    let current = queue;\r\n\r\n    queue = [];\r\n\r\n    while (length--) {\r\n        let callback = current[length];\r\n        // if in case one is defined as important, the execution will be forced\r\n        if (callback[IMPORTANT] || performance.now() - time < maxFps) {\r\n            callback();\r\n        } else {\r\n            queue = queue.concat(current.slice(0, length + 1));\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (queue.length) {\r\n        requestAnimationFrame(clearQueue);\r\n        return;\r\n    }\r\n    running = false;\r\n}\r\n/**\r\n * add a task to the queue\r\n * @param {Function} callback\r\n * @returns {Promise} Generate a promise that show  if the queue is complete\r\n */\r\nfunction addQueue(callback) {\r\n    if (!running) {\r\n        running = true;\r\n        defer.then(clearQueue);\r\n    }\r\n    // if the callback is defined as IMPORTANT,\r\n    // it is assumed to be in favor of the tree\r\n    // of the DOM  that must be added by unshift,\r\n    // assuming that the mount will be carried\r\n    // out in order, the shift priority only works\r\n    // after the first render\r\n    if (!queue.includes(callback))\r\n        queue[callback[IMPORTANT] ? \"unshift\" : \"push\"](callback);\r\n}\n\nfunction load(self, componentRender, componentError) {\r\n    if (self.mount) return;\r\n\r\n    let id = Symbol(\"vnode\");\r\n\r\n    let isPrevent;\r\n    let isUnmount;\r\n\r\n    self[ELEMENT_PROPS] = {};\r\n\r\n    let isMounted;\r\n\r\n    let resolveUpdate;\r\n\r\n    let rerender = () => {\r\n        // disables blocking, allowing the cycle to be regenerate\r\n        isPrevent = false;\r\n        // After the first render it disables the important condition\r\n        if (rerender[IMPORTANT]) rerender[IMPORTANT] = false;\r\n        try {\r\n            render(\r\n                hooks.load(componentRender, { ...self[ELEMENT_PROPS] }),\r\n                self,\r\n                id\r\n            );\r\n\r\n            resolveUpdate();\r\n        } catch (e) {\r\n            (componentError || console.error)(e);\r\n        }\r\n    };\r\n    // mark the first render as important, self speeds up the rendering\r\n    rerender[IMPORTANT] = true;\r\n\r\n    self.update = () => {\r\n        if (isUnmount) return;\r\n        let rendered = self.rendered;\r\n        if (!isPrevent) {\r\n            isPrevent = true;\r\n            // create a promise to observe the status of the update\r\n            rendered = promise(resolve => (resolveUpdate = resolve)).then(\r\n                // the UPDATED state is only propagated through\r\n                // the resolution of the promise\r\n                // Why? ... to improve communication between web-component parent and children\r\n                hooks.updated\r\n            );\r\n\r\n            // if the component is already mounted, avoid using self.mounted,\r\n            // to speed up the microtask\r\n            isMounted\r\n                ? addQueue(rerender)\r\n                : self.mounted.then(() => {\r\n                      isMounted = true;\r\n                      addQueue(rerender);\r\n                  });\r\n        }\r\n\r\n        return (self.rendered = rendered);\r\n    };\r\n\r\n    // any update from hook is added to a separate queue\r\n    let hooks = createHookCollection(() => addQueue(self.update), self);\r\n\r\n    // creates a collection of microtask\r\n    // associated with the mounted of the component\r\n\r\n    self.mounted = promise(\r\n        resolve =>\r\n            (self.mount = () => {\r\n                isMounted = false;\r\n                // allows the reuse of the component when it is isUnmounted and mounted\r\n                if (isUnmount == true) {\r\n                    isUnmount = false;\r\n                    self.mounted = self.update();\r\n                }\r\n                resolve();\r\n            })\r\n    );\r\n    /**\r\n     * creates a collection of microtask\r\n     * associated with the unmounted of the component\r\n     */\r\n    self.unmounted = promise(\r\n        resolve =>\r\n            (self.unmount = () => {\r\n                isUnmount = true;\r\n                hooks.unmount();\r\n                resolve();\r\n            })\r\n    );\r\n\r\n    self.initialize();\r\n\r\n    self.update();\r\n}\r\n\r\n/**\r\n * register the component, be it a class or function\r\n * @param {string} nodeType\r\n * @param {Function} component\r\n * @return {Function} returns a jsx component\r\n */\r\nfunction customElement(nodeType, component, options) {\r\n    if (isFunction(nodeType)) {\r\n        // By defining nodeType as a function, custom ELement\r\n        // allows the assignment of a constructor to be extended\r\n        let BaseElement = component || HTMLElement;\r\n\r\n        component = nodeType;\r\n\r\n        let { props, error } = component;\r\n\r\n        /**@type {Function[]}*/\r\n        let initialize = [];\r\n\r\n        /**@type {string[]} */\r\n        let attrs = [];\r\n\r\n        let CustomElement = class extends BaseElement {\r\n            constructor() {\r\n                super();\r\n                /**\r\n                 * identifier to store the virtual-dom state,\r\n                 * this is unique between instances of the\r\n                 * component to securely consider the host status\r\n                 */\r\n                load(this, component, error);\r\n            }\r\n            connectedCallback() {\r\n                load(this, component, error);\r\n                this.mount();\r\n            }\r\n            disconnectedCallback() {\r\n                this.unmount();\r\n            }\r\n            attributeChangedCallback(attr, oldValue, value) {\r\n                if (attr === this[ELEMENT_IGNORE_ATTR] || oldValue === value)\r\n                    return;\r\n                this[attrToProp(attr)] = value;\r\n            }\r\n            initialize() {\r\n                let length = initialize.length;\r\n                while (length--) initialize[length](this);\r\n            }\r\n        };\r\n\r\n        let prototype = CustomElement.prototype;\r\n\r\n        for (let prop in props)\r\n            setProperty$1(prototype, initialize, attrs, prop, props[prop]);\r\n\r\n        CustomElement.observedAttributes = attrs;\r\n\r\n        CustomElement.props = props;\r\n\r\n        return CustomElement;\r\n    } else {\r\n        let { base, ...opts } = options || {};\r\n        let define = () =>\r\n            customElements.define(\r\n                nodeType,\r\n                customElement(component, base),\r\n                opts\r\n            );\r\n        // it allows to wait for one or more webcomponents\r\n        // to be defined before the definition of this\r\n        opts.waitFor\r\n            ? Promise.all(\r\n                  []\r\n                      .concat(opts.waitFor)\r\n                      .map(nodeType => customElements.whenDefined(nodeType))\r\n              ).then(define)\r\n            : define();\r\n        return props =>\r\n            opts.extends\r\n                ? createElement(opts.extends, { ...props, is: nodeType })\r\n                : createElement(nodeType, props);\r\n    }\r\n}\r\n\r\nfunction setProperty$1(prototype, initialize, attrs, prop, schema) {\r\n    let attr = propToAttr(prop);\r\n\r\n    schema = schema.name ? { type: schema } : schema;\r\n\r\n    // avoid rewriting the prototype\r\n    if (prop in prototype) return;\r\n\r\n    function set(nextValue) {\r\n        let prevValue = this[ELEMENT_PROPS][prop];\r\n\r\n        if (isFunction(nextValue)) {\r\n            nextValue = nextValue(prevValue);\r\n        }\r\n        let { value, error } = formatType(nextValue, schema.type);\r\n\r\n        if (error && value != null) {\r\n            throw `the observable [${prop}] must be of the type [${schema.type.name}]`;\r\n        }\r\n\r\n        if (prevValue == value) return;\r\n\r\n        this[ELEMENT_PROPS][prop] = value;\r\n\r\n        let rendered = this.update();\r\n\r\n        if (schema.event) {\r\n            // The event is only dispatched if the component has finished\r\n            // the rendering cycle, this is useful to observe the changes\r\n            rendered.then(() =>\r\n                dispatchEvent(this, schema.event.type || prop, schema.event)\r\n            );\r\n        }\r\n\r\n        if (schema.reflect) {\r\n            // the default properties are only reflected once the web-component is mounted\r\n            this.mounted.then(() => {\r\n                this[ELEMENT_IGNORE_ATTR] = attr; //update is prevented\r\n                setAttr(\r\n                    this,\r\n                    attr,\r\n                    schema.type == Boolean && !value ? null : value //\r\n                );\r\n                this[ELEMENT_IGNORE_ATTR] = false; // an upcoming update is allowed\r\n            });\r\n        }\r\n    }\r\n\r\n    function get() {\r\n        return this[ELEMENT_PROPS][prop];\r\n    }\r\n\r\n    Object.defineProperty(prototype, prop, { set, get });\r\n\r\n    if (\"value\" in schema) {\r\n        initialize.push(self => {\r\n            let { value } = schema;\r\n            self[prop] = isFunction(value) ? value() : value;\r\n        });\r\n    }\r\n    attrs.push(attr);\r\n}\n\nfunction useProp(name) {\r\n    let ref = useHost();\r\n    if (name in ref.current) {\r\n        if (!ref[name]) {\r\n            ref[name] = [null, nextValue => (ref.current[name] = nextValue)];\r\n        }\r\n        ref[name][0] = ref.current[name];\r\n        return ref[name];\r\n    }\r\n}\r\n\r\nfunction useEvent(type, customEventInit) {\r\n    let ref = useHost();\r\n    if (!ref[type]) {\r\n        ref[type] = detail =>\r\n            dispatchEvent(\r\n                ref.current,\r\n                type,\r\n                detail ? { ...customEventInit, detail } : customEventInit\r\n            );\r\n    }\r\n    return ref[type];\r\n}\r\n\r\nfunction usePublic(name, value) {\r\n    let { current } = useHost();\r\n    if (current[name] != value) {\r\n        current[name] = value;\r\n    }\r\n    return current[name];\r\n}\n\nexport { createHookCollection, customElement, createElement as h, render, toVnode, useCallback, useEffect, useEvent, useHook, useHost, useMemo, useProp, usePublic, useReducer, useRef, useRender, useState };\n//# sourceMappingURL=core.js.map\n","import { h, customElement } from \"atomico\";\r\n\r\nfunction AtomicoBrand({ color, size }) {\r\n  return (\r\n    <svg width={size} viewBox=\"0 0 745 260\">\r\n      <g id=\"logo-white\" transform=\"translate(-311 -276)\">\r\n        <rect\r\n          id=\"padding\"\r\n          width=\"745\"\r\n          height=\"260\"\r\n          transform=\"translate(311 276)\"\r\n          opacity=\"0\"\r\n        />\r\n        <g id=\"isotipo\" transform=\"translate(-62.399 477.454) rotate(-45)\">\r\n          <path\r\n            id=\"Trazado_8\"\r\n            data-name=\"Trazado 8\"\r\n            d=\"M-1245.356,341.791a31.088,31.088,0,0,1-4.215-.288l-20.068-20.068c2.127.44,4.306.788,6.474,1.034l19.286,19.286C-1244.374,341.78-1244.871,341.791-1245.356,341.791Zm5.908-.569-18.344-18.344c.939.037,1.9.055,2.855.055.862,0,1.735-.015,2.594-.046l17.176,17.176a30.854,30.854,0,0,1-4.281,1.158Zm-16.772-1.4a30.547,30.547,0,0,1-10.91-7.047,30.561,30.561,0,0,1-7.048-10.912l17.959,17.958Zm24.547-1.226-16.019-16.019c1.6-.159,3.212-.375,4.8-.641l14.663,14.663a30.678,30.678,0,0,1-3.443,2Zm6.267-4.137-13.344-13.344c1.44-.33,2.891-.71,4.31-1.129l11.8,11.8c-.3.331-.621.663-.945.987-.584.585-1.2,1.151-1.823,1.684Zm5-5.4h0l-10.289-10.289c1.308-.466,2.625-.979,3.914-1.526l8.481,8.481a30.713,30.713,0,0,1-2.1,3.334Zm3.688-6.716h0l-6.651-6.651c1.2-.584,2.4-1.211,3.573-1.866l4.383,4.383a30.8,30.8,0,0,1-1.3,4.134Zm2.014-8.39h0l-1.972-1.972c.7-.44,1.413-.9,2.111-1.374a31.094,31.094,0,0,1-.138,3.346Z\"\r\n            transform=\"translate(1649.064 56.05)\"\r\n            fill={color}\r\n          />\r\n          <path\r\n            id=\"Trazado_7\"\r\n            data-name=\"Trazado 7\"\r\n            d=\"M-1321.651,191.587a68.963,68.963,0,0,1-13.8-1.391,68.11,68.11,0,0,1-12.85-3.989,68.465,68.465,0,0,1-11.629-6.312,68.952,68.952,0,0,1-10.132-8.359,68.949,68.949,0,0,1-8.359-10.132,68.46,68.46,0,0,1-6.312-11.628,68.122,68.122,0,0,1-3.989-12.85,68.977,68.977,0,0,1-1.391-13.8,68.976,68.976,0,0,1,1.391-13.8,68.121,68.121,0,0,1,3.989-12.85,68.462,68.462,0,0,1,6.312-11.628,68.953,68.953,0,0,1,8.359-10.131,68.955,68.955,0,0,1,10.132-8.359,68.47,68.47,0,0,1,11.629-6.312,68.116,68.116,0,0,1,12.85-3.989,68.965,68.965,0,0,1,13.8-1.391,68.751,68.751,0,0,1,16.407,1.979,68.093,68.093,0,0,1,14.975,5.622,68.669,68.669,0,0,1,13.07,8.794A68.938,68.938,0,0,1-1266.5,82.56a43.4,43.4,0,0,0-28.277,40.57A43.4,43.4,0,0,0-1266.5,163.7a68.937,68.937,0,0,1-10.694,11.493,68.67,68.67,0,0,1-13.07,8.794,68.092,68.092,0,0,1-14.975,5.622A68.751,68.751,0,0,1-1321.651,191.587Z\"\r\n            transform=\"translate(1716.109 183.328)\"\r\n            fill={color}\r\n          />\r\n          <path\r\n            id=\"Trazado_6\"\r\n            data-name=\"Trazado 6\"\r\n            d=\"M-1388.348,73.679h31.8a38.414,38.414,0,0,1-15.9,3.421A38.415,38.415,0,0,1-1388.348,73.679Zm-7.374-4.394a38.8,38.8,0,0,1-5.263-4.816h57.072a38.8,38.8,0,0,1-5.263,4.816Zm-8.713-9.21a38.535,38.535,0,0,1-2.765-4.816h69.5a38.536,38.536,0,0,1-2.765,4.816Zm-4.555-9.21a38.263,38.263,0,0,1-1.28-4.816h75.642a38.263,38.263,0,0,1-1.28,4.816Zm-1.886-9.21q-.122-1.536-.123-3.105,0-.86.037-1.71h77.025q.037.85.037,1.71,0,1.567-.123,3.105Zm.357-9.21a38.333,38.333,0,0,1,1.088-4.815h73.963a38.354,38.354,0,0,1,1.088,4.815Zm2.681-9.21a38.456,38.456,0,0,1,2.5-4.815h65.766a38.472,38.472,0,0,1,2.5,4.815Zm5.644-9.21a38.789,38.789,0,0,1,4.738-4.815h50.013a38.764,38.764,0,0,1,4.738,4.815Zm11.073-9.21A38.373,38.373,0,0,1-1372.449,0a38.373,38.373,0,0,1,18.671,4.815Z\"\r\n            transform=\"translate(1837 267.543)\"\r\n            fill={color}\r\n          />\r\n        </g>\r\n        <path\r\n          id=\"logo\"\r\n          d=\"M59.405,0H69.869L42.51-75.537H31.065L3.6,0H14.061l6.1-16.9H53.3ZM50.467-24.961H23L36.733-63.329ZM84.039-16.35c0,11.99,6,16.35,16.568,16.35h8.938V-8.393h-7.3c-6.1,0-8.284-2.071-8.284-7.957V-51.557h15.587v-8.175H93.958V-74.774H84.039v15.042H76.3v8.175h7.739Zm94.176-13.625c0-18.857-13.189-30.738-30.193-30.738-16.9,0-30.193,11.881-30.193,30.738,0,18.966,12.862,30.956,29.757,30.956C164.59.981,178.215-11.009,178.215-29.975Zm-50.249,0c0-15.042,9.483-22.127,19.947-22.127,10.246,0,20.165,7.085,20.165,22.127,0,15.151-10.137,22.236-20.492,22.236S127.966-14.824,127.966-29.975ZM277.514,0h9.81V-35.207c0-17.113-10.573-25.615-24.2-25.615-9.156,0-17.658,4.687-21.146,13.3-3.924-8.938-12.1-13.3-21.909-13.3-7.848,0-14.933,3.379-18.857,9.7v-8.611h-9.919V0h9.919V-32.918c0-12.862,6.867-19.293,16.9-19.293,9.81,0,16.35,6.213,16.35,18.421V0h9.81V-32.918c0-12.862,6.867-19.293,16.9-19.293,9.81,0,16.35,6.213,16.35,18.421Zm26.051,0h9.919V-59.732h-9.919Zm5.123-69.433a6.609,6.609,0,0,0,6.54-6.758,6.609,6.609,0,0,0-6.54-6.758,6.655,6.655,0,0,0-6.758,6.758A6.655,6.655,0,0,0,308.688-69.433Zm17.985,39.458c0,18.966,12.1,30.956,29.1,30.956C370.6.981,380.3-7.3,383.353-19.184H372.671c-2.18,7.521-8.066,11.772-16.895,11.772-10.9,0-18.966-7.739-18.966-22.563,0-14.606,8.066-22.345,18.966-22.345,8.829,0,14.824,4.578,16.895,11.772h10.682C380.3-53.083,370.6-60.713,355.776-60.713,338.772-60.713,326.673-48.723,326.673-29.975Zm126.549,0c0-18.857-13.189-30.738-30.193-30.738-16.9,0-30.193,11.881-30.193,30.738C392.836-11.009,405.7.981,422.593.981,439.6.981,453.222-11.009,453.222-29.975Zm-50.249,0c0-15.042,9.483-22.127,19.947-22.127,10.246,0,20.165,7.085,20.165,22.127,0,15.151-10.137,22.236-20.492,22.236S402.973-14.824,402.973-29.975Z\"\r\n          transform=\"translate(548 447)\"\r\n          fill={color}\r\n        />\r\n      </g>\r\n    </svg>\r\n  );\r\n}\r\n\r\nAtomicoBrand.props = {\r\n  size: {\r\n    type: Number,\r\n    value: 280\r\n  },\r\n  color: {\r\n    type: String,\r\n    value: \"#fff\"\r\n  }\r\n};\r\n\r\nexport default customElement(\"atomico-brand\", AtomicoBrand);\r\n"],"names":["AtomicoBrand","color","size","h","props","type","Number","value","String","customElement"],"mappings":"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"}